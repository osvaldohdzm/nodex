vamos mejro per aun no esta sobrealapado 

http://192.168.0.4:4545/graph

===== frontend/tsconfig.json =====
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@components/*": [
        "components/*"
      ],
      "@styles/*": [
        "styles/*"
      ],
      "@utils/*": [
        "utils/*"
      ]
    },
    "typeRoots": ["./node_modules/@types", "./src/types"] // Added ./src/types for custom type definitions
  },
  "include": [
    "src", // Standard include
    "src/types" // Include custom types directory if you create one (e.g., src/types/custom.d.ts)
  ],
  "exclude": ["node_modules"] // Standard exclude
}

===== frontend/.babelrc =====
{
  "presets": ["react-app"],
  "plugins": ["@babel/plugin-proposal-nullish-coalescing-operator"]
}


===== frontend/eslint.config.mjs =====
// eslint.config.mjs
import globals from "globals"; 
import pluginJs from "@eslint/js"; // Renamed to avoid conflict if you meant something else by 'js' 
import pluginReact from "eslint-plugin-react"; 
import pluginReactHooks from "eslint-plugin-react-hooks"; // Added this 
import { defineConfig } from "eslint/config"; // Keep if using ESLint v9+ style 
 
export default defineConfig([ 
  { 
    files: ["src/**/*.{js,jsx,ts,tsx}"], // Apply to all relevant files in src 
    plugins: { 
      react: pluginReact, 
      "react-hooks": pluginReactHooks, // Register the plugin 
    }, 
    languageOptions: { 
      globals: globals.browser, 
      ecmaVersion: 2021, 
      sourceType: 'module', 
      parserOptions: { 
        ecmaFeatures: { 
          jsx: true, 
        }, 
      }, 
    }, 
    rules: { 
      ...pluginJs.configs.recommended.rules, // Basic JS rules 
      ...pluginReact.configs.recommended.rules, // React specific rules 
      ...pluginReactHooks.configs.recommended.rules, // Rules for Hooks 
      "react/react-in-jsx-scope": "off", // Not needed with new JSX transform 
      "react/jsx-uses-react": "off",    // Not needed with new JSX transform 
      "no-unused-vars": ["warn", { "argsIgnorePattern": "^_" }], // Warn on unused vars 
    }, 
    settings: { 
      react: { 
        version: "detect", // Automatically detect React version 
      }, 
    }, 
  } 
]);


===== frontend/tailwind.config.js =====
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx,css}', './public/index.html'],
  theme: {
    extend: {},
  },
  plugins: [],
};


===== frontend/src/styles/globals.css =====
@tailwind base;
@tailwind components;
@tailwind utilities;

/* React Flow specific styles */
/* Estas clases ya no son necesarias aquí si el layout se maneja bien con flex/grid y w-full/h-full */
/* .react-flow-container {
  width: 100%;
  height: 100%;
  position: relative;
}

.react-flow__viewport {
  width: 100%;
  height: 100%;
}

.react-flow__background {
  width: 100%;
  height: 100%;
} */

/* Ensure proper sizing for the graph container */
/* Esta clase es buena, la usaremos */
.graph-container {
  width: 100%;
  /* height: 100%; Let flex-grow determine height */
  min-height: 300px; /* Fallback minimum height */
  position: relative; /* Important for ReactFlow's positioning context */
}

:root {
  --bg-primary: #03070C; /* Muy oscuro, casi negro azulado */
  --bg-secondary: #0A0F1A; /* Azul oscuro para elementos secundarios */
  --bg-glass: rgba(10, 15, 26, 0.6);
  --border-glass: rgba(0, 229, 255, 0.2);
  --text-primary: #E0E7FF; /* Texto principal, azul claro/lavanda */
  --text-secondary: #94A3B8; /* Texto secundario, gris azulado */
  --accent-cyan: #00E5FF; /* Acento principal, cian brillante */
  --accent-cyan-darker: #00B8D4; /* Cian más oscuro para bordes o estados hover */
  
  --accent-pink: #F472B6;
  --accent-purple: #A78BFA;
  --accent-orange: #F59E0B;
  --accent-green: #34D399;

  --input-bg: #101827; /* Fondo para inputs */
  --input-border: #303F5E; /* Borde para inputs y elementos sutiles del grafo */
  --input-focus-border: var(--accent-cyan); /* Corregido: sin espacio */

  /* Estilos específicos del Grafo */
  --graph-bg: var(--bg-primary); /* Corregido: sin espacio */
  --graph-lines-color: var(--input-border);

  --node-bg: var(--bg-secondary);
  --node-border: var(--accent-cyan-darker);
  --node-border-selected: var(--accent-cyan);
  --node-shadow-selected: 0 0 15px var(--accent-cyan);
  
  /* Colores específicos por tipo de nodo (ejemplos) */
  --node-person-icon-color: var(--accent-cyan); /* Corregido */
  --node-company-icon-color: var(--accent-pink); /* Corregido */
  --node-generic-icon-color: var(--text-secondary); /* Corregido */

  --edge-default-color: #6B7280;
  --edge-selected-color: var(--accent-cyan); /* Corregido */
  --edge-label-color: var(--text-secondary); /* Corregido */

  /* Variables de styles.css (para consistencia si se usan en otros lados) */
  --hue: 200;
  --saturation-accent: 100%;
  --lightness-accent: 50%;
  --first-color: hsl(var(--hue), var(--saturation-accent), var(--lightness-accent)); /* Corregido */
  --first-color-alt: hsl(var(--hue), var(--saturation-accent), 45%);
  --first-color-light: hsl(var(--hue), var(--saturation-accent), 65%);
  --bg-dark-primary: #05080D;
  --bg-form-color: hsla(212, 70%, 10%, 0.75);
  --input-bg-color: #0E1625;
  --title-color: var(--first-color); /* Corregido */
  --text-color: #C0C8D8;
  --text-color-light: #8892b0;
  --text-on-accent: var(--bg-dark-primary); /* Corregido */
  --body-color: var(--bg-dark-primary); /* Corregido */
  --container-color: var(--bg-form-color); /* Corregido */
  --input-border-color: hsl(var(--hue), var(--saturation-accent), 35%);
}

body, #root, .App {
  @apply bg-bg-primary text-text-primary font-sans;
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  flex-grow: 1; /* Asegurar que ocupen toda la altura disponible */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--bg-secondary); /* Corregido */
}
::-webkit-scrollbar-thumb {
  background: var(--accent-cyan-darker); /* Corregido */
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--accent-cyan); /* Corregido */
}

/* React Flow specific styles */
.react-flow__minimap {
  background-color: var(--bg-secondary) !important;
  border: 1px solid var(--accent-cyan-darker) !important;
  border-radius: 4px;
}
.react-flow__controls-button {
  background-color: var(--bg-secondary) !important;
  border: 1px solid var(--accent-cyan-darker) !important;
  color: var(--accent-cyan) !important;
  fill: var(--accent-cyan) !important;
  box-shadow: none !important;
}
.react-flow__controls-button:hover {
  background-color: var(--input-bg) !important;
}
.react-flow__attribution {
  display: none;
}

/* Estilo para las aristas */
.react-flow__edge-path {
  stroke-width: 1.5;
}
.react-flow__edge.selected .react-flow__edge-path,
.react-flow__edge:hover .react-flow__edge-path {
  stroke: var(--edge-selected-color); /* Corregido */
}

.react-flow__handle {
  width: 8px !important;
  height: 8px !important;
  background-color: var(--accent-cyan-darker) !important;
  border: 1px solid var(--bg-secondary) !important;
}
.react-flow__handle-connecting {
  background-color: var(--accent-cyan) !important;
}


@keyframes nodeEnterAnimation {
  0% {
    transform: scale(0.3) translateZ(0);
    opacity: 0;
  }
  70% {
    transform: scale(1.1) translateZ(0);
    opacity: 0.9;
  }
  100% {
    transform: scale(1) translateZ(0);
    opacity: 1;
  }
}

@keyframes edgeEnterAnimation {
  from {
    opacity: 0;
    stroke-dasharray: 2000;
    stroke-dashoffset: 2000;
  }
  to {
    opacity: 1;
    stroke-dashoffset: 0;
  }
}

.react-flow__node.node-appear {
  animation: nodeEnterAnimation 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

.react-flow__edge.edge-appear .react-flow__edge-path {
  animation: edgeEnterAnimation 0.4s ease-out forwards;
  animation-delay: 0.05s; 
}

.react-flow__edge.edge-appear-static .react-flow__edge-path {
  opacity: 1;
}

===== frontend/src/styles/GraphPage.css =====
/* frontend/src/styles/GraphPage.css */

.graph-page-container {
  @apply flex flex-col h-full w-full bg-bg-primary text-text-primary;
  min-height: 0; /* Crucial for flex children that also grow */
}

.upload-panel {
  @apply p-4 bg-bg-secondary shadow-lg rounded-lg flex-shrink-0;
  background-color: var(--bg-glass);
  border: 1px solid var(--border-glass);
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  margin: 1rem;
  position: relative; /* Ensure it's part of the stacking context */
  z-index: 10; /* Higher z-index for the upload panel */
}

.panel-title {
  @apply text-xl font-semibold mb-4 text-accent-cyan text-center;
  text-shadow: 0 0 8px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.5);
}

.file-name-display {
  @apply text-xs text-text-secondary mt-3 text-center;
}

.action-buttons-container {
  @apply flex flex-col sm:flex-row justify-center items-center gap-3 mt-4;
}

.graph-action-button {
  @apply px-5 py-2.5 text-sm font-medium rounded-lg transition-all duration-300 ease-in-out
         flex items-center justify-center gap-2 focus:outline-none;
  background-color: var(--input-bg);
  color: var(--accent-cyan);
  border: 1px solid var(--accent-cyan-darker);
  box-shadow: 0 0 10px 0px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.2),
              inset 0 0 5px 0px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.1);
  text-shadow: 0 0 3px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.4);
}

.graph-action-button:hover:not(:disabled) {
  background-color: var(--accent-cyan-darker);
  color: var(--bg-primary);
  border-color: var(--accent-cyan);
  box-shadow: 0 0 15px 2px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.4),
              inset 0 0 8px 1px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.2);
  transform: translateY(-1px);
}

.graph-action-button:active:not(:disabled) {
  transform: translateY(0px);
  box-shadow: 0 0 5px 0px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.3),
              inset 0 0 3px 0px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.15);
}

.graph-action-button:disabled {
  @apply opacity-50 cursor-not-allowed;
  background-color: var(--input-bg);
  color: var(--text-secondary);
  border-color: var(--input-border);
  box-shadow: none;
  text-shadow: none;
}

.button-icon {
  @apply mr-1.5;
}

/* Specific button colors if needed, but base is good for futuristic */
.overwrite-button {
  /* You can add specific overrides here if needed, e.g., a different accent color */
  /* color: var(--accent-orange); */
  /* border-color: var(--accent-orange); */
}
.overwrite-button:hover:not(:disabled) {
  /* background-color: var(--accent-orange); */
}

.merge-button {
  /* color: var(--accent-green); */
  /* border-color: var(--accent-green); */
}
.merge-button:hover:not(:disabled) {
  /* background-color: var(--accent-green); */
}

.loading-text {
  @apply text-sm text-accent-cyan mt-3 animate-pulse text-center;
}

.graph-viewport-container {
  @apply flex-grow relative rounded-lg shadow-lg;
  background-color: var(--graph-bg);
  min-height: 0; /* Essential for flex-grow to work correctly in nested flex scenarios */
  margin: 0 1rem 1rem 1rem;
  overflow: hidden; /* Crucial for ReactFlow's scrollable container */
  z-index: 1; /* Lower z-index than the upload panel */
}

/* This div directly wraps ReactFlow and MUST have 100% height and width */
.reactflow-wrapper {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.placeholder-message {
  @apply absolute inset-0 flex flex-col items-center justify-center text-text-secondary text-lg p-6 text-center;
  background-color: var(--bg-primary);
}

.json-details-viewer {
  @apply w-full max-w-2xl mt-4 text-left;
}

.json-details-summary {
  @apply cursor-pointer text-accent-cyan hover:underline font-semibold;
}

.json-details-pre {
  @apply text-xs whitespace-pre-wrap break-all text-text-secondary overflow-auto max-h-80 mt-2 p-3 bg-input-bg rounded-md border border-input-border;
}

===== frontend/src/App.js =====
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
// Asegúrate de que estas importaciones de CSS estén comentadas o eliminadas si no las necesitas aquí directamente
// import './App.css'; // Comentado si los estilos principales están en globals.css o son de Tailwind
import LoginPage from './pages/LoginPage'; // .tsx extension is usually not needed here
import GraphPage from './pages/GraphPage'; // .tsx extension is usually not needed here
// import PrivateRoute from './components/auth/PrivateRoute'; // Module not found - Commented out
import './styles/globals.css'; // Importante: tus estilos globales y Tailwind

function App() {
  console.log("App component is rendering");
  // Esta variable isAuthenticated se usa para la redirección inicial en la ruta "/"
  // PrivateRoute maneja la autenticación para las rutas protegidas después de eso.
  // const isAuthenticated = !!localStorage.getItem('access_token'); // Used below

  return (
    <Router>
      {/* Contenedor principal de la aplicación */}
      <div className="App flex flex-col h-screen bg-gray-700"> {/* Fondo gris oscuro para ver el contenedor App */}
        <header
          className="App-header" // Puedes añadir clases de Tailwind aquí si quieres
          style={{
            backgroundColor: '#1e1e1e', // Un color de header distintivo
            padding: '20px',
            textAlign: 'center',
            color: 'white',
            flexShrink: 0, // Importante: Evita que el header se encoja si el contenido de main es grande
            borderBottom: '2px solid var(--accent-cyan)' // Un borde para distinguirlo
          }}
        >
          <h1>Nodex</h1>
        </header>

        {/* Contenedor principal del contenido */}
        <main
          className="flex-grow overflow-auto" // Tailwind classes para que ocupe el espacio y permita scroll
          style={{
            border: '5px solid limegreen', // Borde verde para depurar <main>
            backgroundColor: 'rgba(50, 50, 150, 0.3)', // Fondo azulado semi-transparente para <main>
            // minHeight: '0', // Asegura que flex-grow pueda funcionar correctamente.
            // display: 'flex', // Si quieres que el contenido interno use flex
            // flexDirection: 'column', // Si quieres que el contenido interno se apile verticalmente
          }}
        >
          {/* Div interno para probar el layout dentro de main */}
          <div style={{
              border: '3px dashed yellow',
              // flexGrow: 1, // Descomenta si main tiene display:flex y flexDirection:column y quieres que este div crezca
              minHeight: '100%', // Intenta que este div ocupe toda la altura de main
              backgroundColor: 'rgba(255, 255, 0, 0.1)',
              padding: '10px', // Añade padding para ver el contenido
              display: 'flex', // Para que GraphPage pueda usar flex si es necesario
              flexDirection: 'column' // Para que GraphPage pueda usar flex si es necesario
            }}
          >
            <p style={{color: 'yellow', textAlign: 'center', flexShrink: 0}}>CONTENIDO INTERNO DE MAIN - ¿VES ESTO EN AMARILLO?</p>
            
            {/* Las Rutas van aquí, dentro del div amarillo para ver si se renderizan */}
            <div style={{ flexGrow: 1, border: '2px solid orange', position: 'relative' /* Para ReactFlow */}}> {/* Contenedor para las rutas */}
              <Routes>
                <Route path="/login" element={<LoginPage />} />
                {/* <Route element={<PrivateRoute />}> // PrivateRoute.tsx not found
                  <Route path="/graph" element={<GraphPage />} />
                </Route> */}
                {/* Temporarily making /graph public for testing without PrivateRoute */}
                <Route path="/graph" element={<GraphPage />} />
                <Route
                  path="/"
                  element={
                    // Re-evaluar aquí para la redirección inicial
                    localStorage.getItem('access_token') ? <Navigate to="/graph" replace /> : <Navigate to="/login" replace />
                  }
                />
                {/* Ruta catch-all para redirigir si no se encuentra la ruta */}
                <Route
                  path="*"
                  element={<Navigate to="/" replace />}
                />
              </Routes>
            </div>
          </div>
        </main>
      </div>
    </Router>
  );
}

export default App;

===== frontend/src/App.css =====
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background-color: #121212;
  color: #ffffff;
}

.App-header {
  background-color: #1e1e1e;
  padding: 20px;
  text-align: center;
}

main {
  padding: 0; /* Remove padding to avoid layout issues for GraphPage */
}


===== frontend/src/index.js =====
import React from 'react';
import { createRoot } from 'react-dom/client';
import './styles/globals.css'; // MANTENER ESTE (Tailwind y variables principales)
// import './assets/css/styles.css'; // COMENTAR TEMPORALMENTE para aislar problemas de CSS
// import './App.css'; // COMENTAR TEMPORALMENTE para aislar problemas de CSS
import App from './App.tsx'; // Changed from App to App.tsx

const container = document.getElementById('root');
const root = createRoot(container);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

===== frontend/src/App.tsx =====
// frontend/src/App.tsx
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import LoginPage from './pages/LoginPage';
import GraphPageWithProvider from './pages/GraphPage';
import './styles/globals.css';

const AppContent: React.FC = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(!!localStorage.getItem('access_token'));
  const location = useLocation();

  useEffect(() => {
    const checkAuth = () => {
      const token = localStorage.getItem('access_token');
      setIsAuthenticated(!!token);
    };
    checkAuth();
    const handleLoginSuccess = () => {
      console.log("AppContent: loginSuccess event received, updating auth state.");
      checkAuth();
    };
    window.addEventListener('loginSuccess', handleLoginSuccess);
    return () => {
      window.removeEventListener('loginSuccess', handleLoginSuccess);
    };
  }, [location.key]);

  console.log("AppContent rendering, isAuthenticated:", isAuthenticated);

  return (
    // .App class from globals.css applies: bg-bg-primary text-text-primary font-sans flex flex-col min-h-screen
    <div className="App"> 
      <header
        className="App-header" // This class is defined in App.css, ensure it's flex-shrink-0
        style={{
          backgroundColor: 'var(--bg-secondary)',
          padding: '1rem',
          textAlign: 'center',
          color: 'var(--text-primary)',
          flexShrink: 0, 
          borderBottom: '1px solid var(--input-border)'
        }}
      >
        <h1 className="text-2xl font-semibold text-accent-cyan">Nodex</h1>
      </header>
      {/* main needs to be a flex container that grows and allows its children to grow */}
      <main
        className="flex-grow flex flex-col" // Ensures main itself is a flex container and grows
        style={{
          position: 'relative', // For absolutely positioned children if needed
          minHeight: '0', // CRUCIAL for flex children that also grow
        }}
      >
        {/* Routes will render GraphPageWithProvider, which has .graph-page-container (flex-grow) */}
        <Routes>
          <Route 
            path="/login" 
            element={!isAuthenticated ? <LoginPage /> : <Navigate to="/graph" replace />} 
          />
          <Route
            path="/graph"
            element={isAuthenticated ? <GraphPageWithProvider /> : <Navigate to="/login" replace />}
          />
          <Route
            path="/"
            element={<Navigate to={isAuthenticated ? "/graph" : "/login"} replace />}
          />
          <Route
            path="*"
            element={<Navigate to="/" replace />}
          />
        </Routes>
      </main>
    </div>
  );
};

function App() {
  return (
    <Router>
      <AppContent />
    </Router>
  );
}

export default App;

===== frontend/src/assets/css/styles.css =====
/* GLE FONTS ===============*/
@import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap");

/* ============ VARIABLES CSS ===============*/
:root {
  /* ======= Colors (Inspired by User Image) ==========*/
  --hue: 200; /* Use hue for cyan/blue tones (e.g., 200 for a bright sky blue/cyan) */
  --saturation-accent: 100%;
  --lightness-accent: 50%; /* For a bright #00E5FF like cyan */

  --first-color: hsl(var(--hue), var(--saturation-accent), var(--lightness-accent)); /* Bright Cyan */
  --first-color-alt: hsl(var(--hue), var(--saturation-accent), 45%); /* Slightly darker cyan for hover */
  --first-color-light: hsl(var(--hue), var(--saturation-accent), 65%); /* Lighter cyan */

  --bg-dark-primary: #05080D; /* Very dark, almost black with a hint of blue */
  --bg-form-color: hsla(212, 70%, 10%, 0.75); /* Dark blue, slightly transparent for form background */
  --input-bg-color: #0E1625; /* Dark blue for input background */

  --title-color: var(--first-color); /* Bright Cyan for titles */
  --text-color: #C0C8D8; /* Light grayish blue for general text */
  --text-color-light: #8892b0; /* Muted blue-gray for labels, secondary text */
  --text-on-accent: var(--bg-dark-primary); /* Dark text for buttons with cyan background */

  --body-color: var(--bg-dark-primary);
  --container-color: var(--bg-form-color); /* For the form itself */
  --input-border-color: hsl(var(--hue), var(--saturation-accent), 35%); /* Darker cyan for input border */

  /* ======== Font and typography ==========*/
  --body-font: 'Poppins', sans-serif;
  --h1-font-size: 1.75rem;
  --normal-font-size: .938rem;
  --small-font-size: .813rem;

  /* ======== z-index ==========*/
  --z-fixed: 100;
  --z-modal: 1000;
}

/* Responsive typography */
@media screen and (min-width: 968px) {
  :root {
    --h1-font-size: 2.25rem;
    --normal-font-size: 1rem;
    --small-font-size: .875rem;
  }
}

/* ============= BASE ===============*/
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

body {
  font-family: var(--body-font);
  font-size: var(--normal-font-size);
  background-color: var(--body-color);
  background-image: radial-gradient(ellipse at center, hsl(var(--hue), 30%, 10%) 0%, var(--body-color) 70%);
  background-repeat: no-repeat;
  background-attachment: fixed;
  min-height: 100vh;
  color: var(--text-color);
  line-height: 1.6;
}

h1 {
  color: var(--title-color); /* Default h1 color, though login__title overrides */
}

a {
  text-decoration: none;
  color: var(--first-color);
}

input,
button {
  font-family: var(--body-font);
  border: none;
  outline: none;
}

/* ============= LOGIN PAGE STYLES ===============*/
.login {
  height: 100vh;
  display: grid;
  align-items: center;
  justify-content: center;
  padding: 1.5rem;
}

#loginBackgroundCanvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
  background-color: var(--body-color);
}

.login-page-container {
  width: 100%;
  height: 100vh;
  overflow: hidden;
}

.login__form {
  position: relative;
  z-index: 1;
  background-color: var(--container-color);
  border: 1px solid hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.2);
  backdrop-filter: blur(8px);
  padding: 2.5rem 2rem;
  border-radius: 1rem;
  box-shadow: 0 8px 32px 0 hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.15),
              0 0 25px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.1) inset;
  width: 100%;
  max-width: 400px;
  text-align: center;
}

.login__title {
  font-size: var(--h1-font-size);
  font-weight: 500;
  margin-bottom: 2rem;
  color: var(--title-color);
  text-shadow: 0 0 8px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.7);
}

.login__content {
  display: grid;
  gap: 1.5rem;
  margin-bottom: 1.25rem;
}

.login__box {
  display: grid;
  grid-template-columns: max-content 1fr;
  align-items: center;
  column-gap: 0.75rem;
  border: 1px solid var(--input-border-color);
  padding: 0.5rem 1rem;
  border-radius: 0.75rem;
  background-color: var(--input-bg-color);
  transition: border-color .3s, box-shadow .3s;
}

.login__box:focus-within {
  border-color: var(--first-color);
  box-shadow: 0 0 10px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.6);
}

.login__icon {
  font-size: 1.25rem;
  color: var(--first-color-light);
  transition: color .3s;
}

.login__box:focus-within .login__icon {
  color: var(--first-color);
}

.login__box-input {
  position: relative;
  width: 100%;
}

.login__input {
  width: 100%;
  padding: 0.9rem 0.25rem;
  background: none;
  color: var(--text-color);
  font-size: var(--normal-font-size);
  letter-spacing: 0.5px;
}

/* Styles for Webkit browser autofill */
.login__input:-webkit-autofill,
.login__input:-webkit-autofill:hover, 
.login__input:-webkit-autofill:focus, 
.login__input:-webkit-autofill:active  {
    -webkit-box-shadow: 0 0 0 30px var(--input-bg-color) inset !important;
    -webkit-text-fill-color: var(--text-color) !important;
    caret-color: var(--first-color) !important;
    border-radius: 0.75rem;
}

.login__label {
  position: absolute;
  left: 0.25rem;
  top: 50%;
  transform: translateY(-50%);
  padding: 0 0.25rem;
  font-size: var(--normal-font-size);
  color: var(--text-color-light);
  font-weight: 400;
  pointer-events: none;
  transition: all 0.2s ease-out;
  background-color: var(--input-bg-color);
  line-height: 1;
}

.login__eye {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.25rem;
  color: var(--text-color-light);
  cursor: pointer;
  transition: color .3s;
}
.login__eye:hover {
  color: var(--first-color);
}

/* Input focus or value present: move up label */
.login__input:focus + .login__label,
.login__input:not(:placeholder-shown) + .login__label {
  top: -0.85rem; /* Adjust this value to position label above input field correctly */
  font-size: .75rem;
  color: var(--first-color);
}

.login__check {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.25rem;
  font-size: var(--small-font-size);
}

.login__check-group {
  display: flex;
  align-items: center;
  gap: .5rem;
}

.login__check-input {
  width: 1rem;
  height: 1rem;
  accent-color: var(--first-color); /* Modern browsers styling for checkbox */
  cursor: pointer;
  background-color: var(--input-bg-color); /* Ensure bg matches for non-accent-color scenarios */
  border: 1px solid var(--input-border-color); /* For consistency */
}
.login__check-input:checked {
    background-color: var(--first-color); /* Explicitly set checked bg */
}


.login__check-label,
.login__forgot {
  color: var(--text-color-light);
  transition: color .3s;
}

.login__check-label:hover, /* Hover for label to make it feel more interactive */
.login__forgot:hover {
  color: var(--first-color);
}

.login__button {
  width: 100%;
  padding: 1rem;
  border-radius: 0.75rem;
  background-color: var(--first-color);
  color: var(--text-on-accent);
  font-weight: 500;
  font-size: var(--normal-font-size);
  cursor: pointer;
  margin-bottom: 2rem;
  transition: background-color .3s, box-shadow .3s;
  box-shadow: 0 4px 15px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.3);
}

.login__button:hover {
  background-color: var(--first-color-alt);
  box-shadow: 0 6px 20px hsla(var(--hue), var(--saturation-accent), var(--lightness-accent), 0.5);
}

.login__button:focus-visible { /* Accessibility focus ring */
  outline: 2px solid var(--first-color-alt);
  outline-offset: 3px;
}

.login__register {
  font-size: var(--small-font-size);
  text-align: center;
  color: var(--text-color-light);
}

.login__register a {
  color: var(--first-color);
  font-weight: 500;
  transition: color .3s, text-decoration .3s;
}

.login__register a:hover {
  color: var(--first-color-light);
  text-decoration: underline;
}

/* Custom scrollbar (Webkit browsers) */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
::-webkit-scrollbar-track {
  background: var(--input-bg-color);
  border-radius: 10px;
}
::-webkit-scrollbar-thumb {
  background: var(--input-border-color);
  border-radius: 10px;
  border: 2px solid var(--input-bg-color); /* Creates a padding effect */
}
::-webkit-scrollbar-thumb:hover {
  background: var(--first-color);
}


===== frontend/src/pages/GraphPage.tsx =====
// frontend/src/pages/GraphPage.tsx
import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';
import ReactFlow, {
  Controls,
  Background,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Node,
  Edge,
  Connection,
  BackgroundVariant,
  MarkerType,
  useReactFlow,
  ReactFlowProvider,
  NodeChange,
  EdgeChange,
  applyNodeChanges,
  applyEdgeChanges,
} from 'reactflow';
import 'reactflow/dist/style.css';
import '../styles/globals.css';
import '../styles/GraphPage.css'; // Import the specific CSS

import JsonUploadButton from '../components/graph/JsonUploadButton';
import PersonNode from '../components/graph/PersonNode';
import CompanyNode from '../components/graph/CompanyNode';
import { UploadCloud, Replace, Layers } from 'lucide-react';

const nodeTypes = {
  person: PersonNode,
  company: CompanyNode,
};

// --- (JsonData and OnlineProfile interfaces remain the same) ---
interface JsonData {
  _id?: { $oid: string };
  curp_online?: { data?: { registros?: Array<any> } };
  ine1?: { data?: Array<any> };
  buro1?: { data?: Array<{ comercios?: Array<any>; domicilios?: Array<any> }> };
  buro2?: { data?: Array<{ comercios2?: Array<any>; domicilios?: Array<any> }> };
  pasaportes2022?: { data?: Array<any> };
  pasaportes2023?: { data?: Array<any> };
  internet1?: { data?: { ResultadosGoogle?: { resultados?: Array<any> }; ResultadosBing?: { [key: string]: any } } };
  internet2?: { data?: Array<any> };
  socios_empresas?: { data?: { datos_subconsulta?: Array<any>; socios?: Array<any> } };
  [key: string]: any;
}

interface OnlineProfile {
  link: string;
  title: string;
  snippet?: string;
  source: string;
}
// --- (defaultNodes and defaultEdges remain the same) ---
const defaultNodes: Node[] = [
  { id: 'center-hub', type: 'company', position: { x: 400, y: 200 }, data: { name: 'Nodex Central Hub', location: 'Cyber Espacio', details: { info: 'Punto de partida de la demostración.'} }, className: 'node-appear' },
  { id: 'analyst-1', type: 'person', position: { x: 150, y: 50 }, data: { name: 'Analista Alpha', title: 'IA de Datos', details: { skill: 'Análisis Predictivo'} }, className: 'node-appear' },
  { id: 'data-stream-A', type: 'company', position: { x: 100, y: 350 }, data: { name: 'Flujo de Datos A', location: 'Sector Gamma', details: { type: 'Información encriptada'} }, className: 'node-appear' },
  { id: 'analyst-2', type: 'person', position: { x: 650, y: 50 }, data: { name: 'Operador Beta', title: 'Vigilancia de Red', details: { skill: 'Seguridad de Redes'} }, className: 'node-appear' },
  { id: 'data-stream-B', type: 'company', position: { x: 700, y: 350 }, data: { name: 'Flujo de Datos B', location: 'Sector Delta', details: { type: 'Comunicaciones Seguras'} }, className: 'node-appear' },
];

const defaultEdges: Edge[] = [
  { id: 'e-hub-analyst1', source: 'center-hub', target: 'analyst-1', label: 'Asigna Tarea', type: 'smoothstep', animated: true, className: 'edge-appear', style: { stroke: 'var(--accent-green)', strokeWidth: 2 }, markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--accent-green)' } },
  { id: 'e-hub-datastreamA', source: 'center-hub', target: 'data-stream-A', label: 'Monitorea', type: 'smoothstep', className: 'edge-appear', style: { stroke: 'var(--accent-purple)' }, markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--accent-purple)' } },
  { id: 'e-analyst1-datastreamA', source: 'analyst-1', target: 'data-stream-A', label: 'Analiza', type: 'smoothstep', className: 'edge-appear' },
  { id: 'e-hub-analyst2', source: 'center-hub', target: 'analyst-2', label: 'Coordina con', type: 'smoothstep', animated: true, className: 'edge-appear', style: { stroke: 'var(--accent-green)', strokeWidth: 2 }, markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--accent-green)' } },
  { id: 'e-hub-datastreamB', source: 'center-hub', target: 'data-stream-B', label: 'Supervisa', type: 'smoothstep', className: 'edge-appear', style: { stroke: 'var(--accent-purple)' }, markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--accent-purple)' } },
  { id: 'e-analyst2-datastreamB', source: 'analyst-2', target: 'data-stream-B', label: 'Protege', type: 'smoothstep', className: 'edge-appear' },
  { id: 'e-analyst1-analyst2', source: 'analyst-1', target: 'analyst-2', label: 'Colabora', type: 'smoothstep', className: 'edge-appear', style: { stroke: 'var(--accent-orange)' }, markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--accent-orange)' } },
];

export const GraphPage: React.FC = () => {
  const firstLoadFitViewDone = useRef(false);
  const [jsonData, setJsonData] = useState<JsonData | null>(null);
  const [fileName, setFileName] = useState<string>('');
  const [nodes, setNodes, onNodesChangeInternal] = useNodesState([]);
  const [edges, setEdges, onEdgesChangeInternal] = useEdgesState([]);
  const [isLoadingGraph, setIsLoadingGraph] = useState(false);
  const [isDemoDataVisible, setIsDemoDataVisible] = useState(true);
  
  const { fitView, getNodes, getEdges } = useReactFlow();
  const demoLoadedRef = useRef(false);
  const animationCleanupRef = useRef<(() => void) | null>(null);

  const memoizedNodeTypes = useMemo(() => nodeTypes, []);

  const onNodesChange = useCallback(
    (changes: NodeChange[]) => setNodes((nds) => applyNodeChanges(changes, nds)),
    [setNodes]
  );
  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    [setEdges]
  );

  const onConnect = useCallback(
    (params: Connection) => {
      if (params.source && params.target) {
        setEdges((eds) => addEdge({
          ...params,
          id: `user-e-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
          type: 'smoothstep', animated: false, style: { stroke: 'var(--edge-default-color)', strokeWidth: 1.5 },
          markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--edge-default-color)' },
          className: 'edge-appear-static'
        }, eds));
      }
    },
    [setEdges]
  );

  const processJsonToGraph = useCallback((data: JsonData): { initialNodes: Node[]; initialEdges: Edge[] } => {
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];
    const nodeIds = new Set<string>();
    let edgeIdCounter = Date.now(); 

    const addNodeSafely = (node: Node) => {
      const uniqueNodeId = `user-node-${node.id}`; 
      if (!nodeIds.has(uniqueNodeId)) {
        newNodes.push({ ...node, id: uniqueNodeId, className: 'node-appear' }); 
        nodeIds.add(uniqueNodeId);
      } else {
        const existingNodeIndex = newNodes.findIndex(n => n.id === uniqueNodeId);
        if (existingNodeIndex !== -1) {
          newNodes[existingNodeIndex] = {
            ...newNodes[existingNodeIndex], ...node, id: uniqueNodeId,
            data: { ...newNodes[existingNodeIndex].data, ...node.data, details: { ...newNodes[existingNodeIndex].data.details, ...node.data.details } }
          };
        }
      }
    };

    const addEdgeInternal = (sourceId: string, targetId: string, label: string, edgeData?: any) => {
      const prefixedSourceId = nodeIds.has(`user-node-${sourceId}`) ? `user-node-${sourceId}` : sourceId;
      const prefixedTargetId = nodeIds.has(`user-node-${targetId}`) ? `user-node-${targetId}` : targetId;

      if (nodeIds.has(prefixedSourceId) && nodeIds.has(prefixedTargetId) && prefixedSourceId !== prefixedTargetId) {
        const edgeId = `user-e-${edgeIdCounter++}-${prefixedSourceId.slice(-10)}-${prefixedTargetId.slice(-10)}-${label.replace(/[^a-zA-Z0-9]/g, '_').slice(0,10)}`;
        newEdges.push({
          id: edgeId, source: prefixedSourceId, target: prefixedTargetId, label,
          type: 'smoothstep', animated: false, style: { stroke: 'var(--edge-default-color)', strokeWidth: 1.5 },
          markerEnd: { type: MarkerType.ArrowClosed, color: 'var(--edge-default-color)' },
          data: edgeData, className: 'edge-appear' 
        });
      }
    };
    
    if (data && Object.keys(data).length > 0) {
        const baseId = data._id?.$oid || 'parsedData'; // Ensure baseId is always a string
        addNodeSafely({ 
            id: `${baseId}-main`, 
            type: 'person', 
            position: { x: 100, y: 100 }, 
            data: { 
                name: `Processed: ${baseId.substring(0,10)}`, 
                title: 'Main Entity',
                details: { fullJson: data }
            } 
        });

        if (newNodes.length > 0 && data.buro1?.data?.[0]?.comercios?.[0]) {
            const comercio = data.buro1.data[0].comercios[0];
            const comercioName = (comercio.institucion || 'ComercioBuro1').replace(/\W/g, '');
            const comercioId = `${baseId}-buro-${comercioName}`;
            addNodeSafely({ 
                id: comercioId, 
                type: 'company', 
                position: { x: 350, y: 100 }, 
                data: { 
                    name: comercio.institucion || 'Buro Co.', 
                    location: 'Buró',
                    details: { ...comercio, source: 'buro1' }
                } 
            });
            addEdgeInternal(`${baseId}-main`, comercioId, 'Rel. Buró');
        }
    }
    console.log(`[processJsonToGraph] Generated ${newNodes.length} nodes, ${newEdges.length} edges.`);
    return { initialNodes: newNodes, initialEdges: newEdges };
  }, []);

  const animateGraphLoad = useCallback((nodesToLoad: Node[], edgesToLoad: Edge[], isOverwrite: boolean) => {
    // ... (animateGraphLoad logic remains the same as previous correct version)
    if (animationCleanupRef.current) {
      animationCleanupRef.current();
    }
    setIsLoadingGraph(true);

    const currentInternalNodes = getNodes();
    const currentInternalEdges = getEdges();
    
    let targetNodes = isOverwrite ? [] : [...currentInternalNodes];
    let targetEdges = isOverwrite ? [] : [...currentInternalEdges];

    const finalNodesMap = new Map(targetNodes.map(n => [n.id, n]));
    nodesToLoad.forEach(n => finalNodesMap.set(n.id, {...finalNodesMap.get(n.id), ...n, data: {...finalNodesMap.get(n.id)?.data, ...n.data}}));
    
    const finalEdgesMap = new Map(targetEdges.map(e => [e.id, e]));
    edgesToLoad.forEach(e => finalEdgesMap.set(e.id, {...finalEdgesMap.get(e.id), ...e}));

    const finalNodes = Array.from(finalNodesMap.values());
    const finalEdges = Array.from(finalEdgesMap.values());
    
    setNodes(isOverwrite ? [] : currentNodes => currentNodes.filter(cn => finalNodesMap.has(cn.id)));
    setEdges(isOverwrite ? [] : currentEdges => currentEdges.filter(ce => finalEdgesMap.has(ce.id)));
    
    let nodeTimeoutId: NodeJS.Timeout | null = null;
    let edgeTimeoutId: NodeJS.Timeout | null = null;

    const batchAdd = (items: any[], setter: React.Dispatch<React.SetStateAction<any[]>>, batchSize: number, delay: number, onDone: () => void) => {
      let i = 0;
      function nextBatch() {
        if (i < items.length) {
          const batch = items.slice(i, Math.min(i + batchSize, items.length));
          setter(prev => {
            const prevMap = new Map(prev.map(item => [item.id, item]));
            batch.forEach(item => prevMap.set(item.id, item));
            return Array.from(prevMap.values());
          });
          i += batch.length;
          if (setter === setNodes) nodeTimeoutId = setTimeout(nextBatch, delay);
          else edgeTimeoutId = setTimeout(nextBatch, delay);
        } else {
          onDone();
        }
      }
      nextBatch();
    };

    setTimeout(() => { 
        batchAdd(finalNodes, setNodes, Math.max(1, Math.floor(finalNodes.length / 15)), 15, () => {
            batchAdd(finalEdges, setEdges, Math.max(1, Math.floor(finalEdges.length / 15)), 15, () => {
                setIsLoadingGraph(false);
                console.log(`Animated graph load complete (${isOverwrite ? 'overwrite' : 'merge'}).`);
                setTimeout(() => {
                    fitView({ duration: 600, padding: 0.15 });
                    firstLoadFitViewDone.current = true; 
                }, 100);
            });
        });
    }, 50);

    animationCleanupRef.current = () => {
      if (nodeTimeoutId) clearTimeout(nodeTimeoutId);
      if (edgeTimeoutId) clearTimeout(edgeTimeoutId);
      setIsLoadingGraph(false);
    };
    return animationCleanupRef.current;
  }, [getNodes, getEdges, setNodes, setEdges, fitView]);

  const handleJsonUploaded = useCallback((uploadedData: JsonData, name?: string, mode: 'overwrite' | 'merge' = 'overwrite') => {
    setJsonData(uploadedData);
    if (name) setFileName(name);
    setIsDemoDataVisible(false);
    firstLoadFitViewDone.current = false;
    
    const { initialNodes, initialEdges } = processJsonToGraph(uploadedData);

    if (initialNodes.length > 0 || initialEdges.length > 0) {
      animateGraphLoad(initialNodes, initialEdges, mode === 'overwrite');
    } else {
      if (mode === 'overwrite') {
        setNodes([]);
        setEdges([]);
      }
      setIsLoadingGraph(false);
      console.warn("Uploaded JSON resulted in no nodes or edges.");
    }
  }, [processJsonToGraph, animateGraphLoad, setNodes, setEdges]);

  useEffect(() => {
    if (isDemoDataVisible && !demoLoadedRef.current) {
      console.log("Loading default demo data (useEffect).");
      firstLoadFitViewDone.current = false;
      animateGraphLoad(
        defaultNodes.map(n => ({...n, data: {...n.data}})),
        defaultEdges.map(e => ({...e})),
        true
      );
      demoLoadedRef.current = true;
    }
  }, [isDemoDataVisible, animateGraphLoad]);

  useEffect(() => {
    return () => {
      if (animationCleanupRef.current) {
        animationCleanupRef.current();
      }
    };
  }, []);

  return (
    <div className="graph-page-container">
      <div className="upload-panel">
        <h2 className="panel-title">Cargar Archivo JSON del Grafo</h2>
        <JsonUploadButton onJsonUploaded={(data, name) => handleJsonUploaded(data, name, 'overwrite')} />
        {fileName && <p className="file-name-display">Archivo cargado: {fileName}</p>}
        <div className="action-buttons-container">
          <button 
            className="graph-action-button overwrite-button"
            onClick={() => {
              if (jsonData) handleJsonUploaded(jsonData, fileName, 'overwrite');
              else alert("Primero carga un archivo JSON para sobrescribir.");
            }}
            disabled={!jsonData || isLoadingGraph}
          >
            <Replace size={18} className="button-icon" />
            Sobrescribir Resultados
          </button>
          <button 
            className="graph-action-button merge-button"
            onClick={() => {
              if (jsonData) handleJsonUploaded(jsonData, fileName, 'merge');
              else alert("Primero carga un archivo JSON para agregar/actualizar.");
            }}
            disabled={!jsonData || isLoadingGraph}
          >
            <Layers size={18} className="button-icon" />
            Agregar y Actualizar
          </button>
        </div>
        {isLoadingGraph && <p className="loading-text">Cargando grafo...</p>}
      </div>

      <div className="graph-viewport-container">
        <div className="reactflow-wrapper">
          {(nodes.length > 0 || isLoadingGraph) ? (
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onConnect={onConnect}
              nodeTypes={memoizedNodeTypes}
              fitView={!firstLoadFitViewDone.current}
              fitViewOptions={{ duration: 800, padding: 0.2 }}
              minZoom={0.05}
              maxZoom={2.5}
              className="themed-flow"
              onlyRenderVisibleElements={true}
            >
              <Controls position="bottom-right" />
              <MiniMap 
                nodeStrokeWidth={3}
                nodeColor={(n) => {
                  if (n.type === 'person') return 'var(--node-person-icon-color)';
                  if (n.type === 'company') return 'var(--node-company-icon-color)';
                  return 'var(--text-secondary)';
                }}
                nodeBorderRadius={2}
                pannable 
                zoomable
                position="top-right"
              />
              <Background 
                variant={BackgroundVariant.Lines} 
                gap={30} 
                size={0.5} 
                color="var(--graph-lines-color)" 
              />
            </ReactFlow>
          ) : !isLoadingGraph ? (
            <div className="placeholder-message">
              <UploadCloud size={64} className="mx-auto mb-6 text-gray-600" />
              <p className="mb-4">Arrastra o selecciona un archivo JSON para visualizar el grafo.</p>
              <p className="mb-2 text-sm">Utiliza el área de carga de arriba.</p>
              {isDemoDataVisible && !demoLoadedRef.current && (
                <p className="text-sm text-accent-green mt-2">Cargando datos de demostración...</p>
              )}
              {jsonData && nodes.length === 0 && (
                <details className="json-details-viewer">
                  <summary className="json-details-summary">JSON cargado pero no se generaron nodos. Ver JSON.</summary>
                  <pre className="json-details-pre">
                    {JSON.stringify(jsonData, null, 2)}
                  </pre>
                </details>
              )}
            </div>
          ) : null}
        </div>
      </div>
    </div>
  );
};

const GraphPageWithProvider: React.FC = () => (
  <ReactFlowProvider>
    <GraphPage />
  </ReactFlowProvider>
);

export default GraphPageWithProvider;

===== frontend/src/pages/LoginPage.tsx =====
import React from 'react';
import LoginForm from '../components/auth/LoginForm';
import AnimatedBackground from '../components/AnimatedBackground.js'; // Now available
import '../assets/css/styles.css';

const LoginPage: React.FC = () => {
  const handleLoginSuccess = () => {
    // This function is called on successful login from LoginForm
    // It can be used to update global state if needed, e.g., force App re-render
    // For now, navigation is handled within LoginForm.
    console.log('Login success callback triggered in LoginPage.');
  };

  return (
    <div className="login-page-container">
      <AnimatedBackground /> {/* Now uncommented */}
      <div className="flex items-center justify-center h-screen">
        <LoginForm onLoginSuccess={handleLoginSuccess} />
      </div>
    </div>
  );
};

export default LoginPage;

===== frontend/src/components/auth/LoginForm.tsx =====
// frontend/src/components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import '../../assets/css/styles.css';

interface LoginFormProps {
  onLoginSuccess: () => void; // This prop might become less critical if AppContent handles state
}

const LoginForm: React.FC<LoginFormProps> = ({ onLoginSuccess }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  // const [showPassword, setShowPassword] = useState(false); // Not used in current UI
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (loading) return;

    setError('');
    setLoading(true);

    try {
      const response = await fetch('http://192.168.0.4:8000/token', { // Ensure this URL is correct
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({ username, password }).toString(),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ detail: 'Login failed. Server error.' }));
        setError(errorData.detail || 'Login failed');
        setLoading(false);
        return;
      }

      const data = await response.json();
      localStorage.setItem('access_token', data.access_token);
      
      // Dispatch a custom event to notify AppContent
      window.dispatchEvent(new CustomEvent('loginSuccess'));
      
      onLoginSuccess(); // Call original prop if still needed for other purposes
      navigate('/graph', { replace: true }); // Use replace to avoid login page in history

    } catch (err) {
      console.error('Login fetch error:', err);
      setError('An error occurred. Please try again.');
    } finally {
      // setLoading(false); // setLoading will be handled by navigation and re-render
      // No, keep setLoading(false) in case of error before navigation
      if (!localStorage.getItem('access_token')) { // Only set loading false if not navigated
          setLoading(false);
      }
    }
  };

  return (
    <div className="login">
      <form className="login__form" onSubmit={handleSubmit}>
        <h1 className="login__title">Login</h1>
        {error && (
          <p className="text-sm text-red-500 mb-4 text-center bg-red-900 bg-opacity-50 p-2 rounded">
            {error}
          </p>
        )}
        <div className="login__content">
          <div className="login__box">
            <div className="login__box-input">
              <input
                type="text"
                className="login__input"
                placeholder=" "
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                id="login-username"
                required
                autoComplete="username"
              />
              <label htmlFor="login-username" className="login__label">Username</label>
            </div>
          </div>
          <div className="login__box">
            <div className="login__box-input">
              <input
                type="password" // Was: type={showPassword ? "text" : "password"}
                className="login__input"
                placeholder=" "
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                id="login-password"
                required
                autoComplete="current-password"
              />
              <label htmlFor="login-password" className="login__label">Password</label>
            </div>
          </div>
        </div>
        <button type="submit" className="login__button" disabled={loading}>
          {loading ? 'Logging in...' : 'Login'}
        </button>
      </form>
    </div>
  );
};

export default LoginForm;

===== frontend/src/components/graph/PersonNode.tsx =====
import React, { memo, useState } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { User, ImagePlus } from 'lucide-react'; // Lucide icons
import classnames from 'classnames';

export interface PersonNodeData {
  name: string;
  title?: string;
  imageUrl?: string;
  onImageUpload?: (nodeId: string, file: File) => void;
  isHighlighted?: boolean;
  details?: any; // Para mostrar más info si es necesario
}

const PersonNode: React.FC<NodeProps<PersonNodeData>> = ({ data, id, selected }) => {
  const [imageSrc, setImageSrc] = useState<string | undefined>(data.imageUrl);
  const [isUploading, setIsUploading] = useState(false);

  const handleImageError = () => {
    setImageSrc(undefined);
  };

  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    // ... (tu lógica de subida de imagen)
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0];
      if (data.onImageUpload) {
        setIsUploading(true);
        try {
          await data.onImageUpload(id, file);
          const reader = new FileReader();
          reader.onloadend = () => {
            setImageSrc(reader.result as string);
          };
          reader.readAsDataURL(file);
        } catch (error) {
          console.error("Image upload failed:", error);
          alert("Image upload failed.");
        } finally {
          setIsUploading(false);
        }
      } else {
        const reader = new FileReader();
        reader.onloadend = () => {
          setImageSrc(reader.result as string);
        };
        reader.readAsDataURL(file);
      }
    }
  };

  const isSelectedOrHighlighted = selected || data.isHighlighted;

  return (
    <div
      className={classnames(
        'person-node w-36 p-3 rounded-lg flex flex-col items-center justify-center text-center relative transition-all duration-200',
        'bg-node-bg border-2', // Usar variables CSS
        isSelectedOrHighlighted ? 'border-node-border-selected shadow-node-selected' : 'border-node-border',
      )}
      style={{
        // @ts-ignore
        '--tw-shadow-color': isSelectedOrHighlighted ? 'var(--accent-cyan)' : 'transparent',
        boxShadow: isSelectedOrHighlighted ? 'var(--node-shadow-selected)' : '0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)' // Sombra sutil por defecto
      }}
    >
      <Handle type="target" position={Position.Top} className="react-flow__handle" />
      
      <div className="w-12 h-12 mb-2 rounded-full flex items-center justify-center bg-black/20 border border-white/10 relative group">
        {imageSrc ? (
          <img src={imageSrc} alt={data.name} className="w-full h-full object-cover rounded-full" onError={handleImageError} />
        ) : (
          <User size={28} className="text-node-person-icon-color" /> // Usar variable CSS para color de icono
        )}
        {data.onImageUpload && (
          <label
            htmlFor={`upload-${id}`}
            className="absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer rounded-full"
          >
            <ImagePlus size={20} className="text-white" />
            <input
              type="file" id={`upload-${id}`} accept="image/*" className="hidden"
              onChange={handleFileChange} disabled={isUploading}
            />
          </label>
        )}
      </div>

      <div className="text-sm font-medium text-text-primary truncate w-full px-1">{data.name}</div>
      {data.title && <div className="text-xs text-text-secondary truncate w-full px-1">{data.title}</div>}

      <Handle type="source" position={Position.Bottom} className="react-flow__handle" />
      {isUploading && <div className="absolute bottom-1 left-1 text-xs text-accent-cyan">Cargando...</div>}
    </div>
  );
};

export default memo(PersonNode);

===== frontend/src/components/graph/JsonUploadButton.tsx =====
import React, { useRef } from 'react';
import { UploadCloud } from 'lucide-react';

interface JsonUploadButtonProps {
  onJsonUploaded: (jsonData: any, fileName?: string) => void; // Añadir fileName opcional
}

const JsonUploadButton: React.FC<JsonUploadButtonProps> = ({ onJsonUploaded }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target?.result as string);
          onJsonUploaded(json, file.name); // Pasar file.name
        } catch (error) {
          console.error("Error parsing JSON:", error);
          alert("Failed to parse JSON file. Please ensure it's valid JSON.");
        }
      };
      reader.readAsText(file);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  const handleButtonClick = () => {
    fileInputRef.current?.click();
  };

  const handleDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('border-accent-cyan', 'bg-gray-700');
    const file = event.dataTransfer.files?.[0];
    if (file && file.type === "application/json") {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const json = JSON.parse(e.target?.result as string);
                onJsonUploaded(json, file.name); // Pasar file.name
            } catch (error) {
                console.error("Error parsing JSON:", error);
                alert("Failed to parse JSON file. Please ensure it's valid JSON.");
            }
        };
        reader.readAsText(file);
    } else if (file) {
        alert("Please drop a valid JSON file.");
    }
  };

  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.add('border-accent-cyan', 'bg-gray-700');
  };

  const handleDragLeave = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('border-accent-cyan', 'bg-gray-700');
  };

  return (
    <div
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      className="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-accent-cyan transition-colors duration-200"
      onClick={handleButtonClick}
    >
      <input
        type="file"
        accept=".json"
        ref={fileInputRef}
        onChange={handleFileChange}
        className="hidden"
      />
      <UploadCloud size={48} className="mx-auto mb-4 text-gray-500" />
      <p className="text-text-secondary">
        Drag & drop your JSON file here, or{' '}
        <span className="text-accent-cyan font-semibold">click to browse</span>.
      </p>
    </div>
  );
};

export default JsonUploadButton;


===== frontend/src/components/graph/GraphCanvas.tsx =====
import React from 'react';

const GraphCanvas: React.FC = () => {
  console.log("GraphCanvas component is rendering (ultra-simple version)");

  return (
    <div
      style={{
        width: '100%',
        height: '100%', // asegura que este div intente llenar a su padre
        backgroundColor: 'rgba(0, 255, 0, 0.3)', // verde brillante, semi-transparente
        border: '5px dashed hotpink', // borde rosa brillante y discontinuo
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'white', // color de texto blanco para contraste
        fontSize: '2rem',
        padding: '20px',
      }}
      className="debug-border-canvas" // si tienes esta clase para depurar
    >
      GraphCanvas Test - ¿Puedes ver esto?
    </div>
  );
};

export default GraphCanvas;


===== frontend/src/components/graph/CompanyNode.tsx =====
import React, { memo, useState } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Building, ImagePlus } from 'lucide-react';
import classnames from 'classnames';

export interface CompanyNodeData {
  name: string;
  location?: string;
  logoUrl?: string;
  onImageUpload?: (nodeId: string, file: File) => void;
  isHighlighted?: boolean;
  details?: any;
}

const CompanyNode: React.FC<NodeProps<CompanyNodeData>> = ({ data, id, selected }) => {
  const [logoSrc, setLogoSrc] = useState<string | undefined>(data.logoUrl);
  const [isUploading, setIsUploading] = useState(false);

  const handleImageError = () => {
    setLogoSrc(undefined);
  };

  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    // ... (tu lógica de subida de imagen)
    if (event.target.files && event.target.files[0] && data.onImageUpload) {
      const file = event.target.files[0];
      setIsUploading(true);
      try {
        await data.onImageUpload(id, file);
        const reader = new FileReader();
        reader.onloadend = () => {
          setLogoSrc(reader.result as string);
        };
        reader.readAsDataURL(file);
      } catch (error) {
        console.error("Logo upload failed:", error);
      } finally {
        setIsUploading(false);
      }
    }
  };
  
  const isSelectedOrHighlighted = selected || data.isHighlighted;

  return (
    <div
      className={classnames(
        'company-node w-44 p-3 rounded-lg flex flex-col items-center justify-center text-center relative transition-all duration-200',
        'bg-node-bg border-2', // Usar variables CSS
        isSelectedOrHighlighted ? 'border-node-border-selected shadow-node-selected' : 'border-node-border',
      )}
      style={{
        // @ts-ignore
        '--tw-shadow-color': isSelectedOrHighlighted ? 'var(--accent-cyan)' : 'transparent',
        boxShadow: isSelectedOrHighlighted ? 'var(--node-shadow-selected)' : '0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)'
      }}
    >
      <Handle type="target" position={Position.Left} className="react-flow__handle" />
      
      <div className="w-12 h-12 mb-2 rounded-md flex items-center justify-center bg-black/20 border border-white/10 relative group">
        {logoSrc ? (
          <img src={logoSrc} alt={data.name} className="w-full h-full object-contain p-1 rounded-md" onError={handleImageError} />
        ) : (
          <Building size={28} className="text-node-company-icon-color" /> // Usar variable CSS para color de icono
        )}
        {data.onImageUpload && (
          <label
            htmlFor={`upload-logo-${id}`}
            className="absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer rounded-md"
          >
            <ImagePlus size={20} className="text-white" />
            <input
              type="file" id={`upload-logo-${id}`} accept="image/*" className="hidden"
              onChange={handleFileChange} disabled={isUploading}
            />
          </label>
        )}
      </div>

      <div className="text-sm font-semibold text-text-primary truncate w-full">{data.name}</div>
      {data.location && <div className="text-xs text-text-secondary truncate w-full">{data.location}</div>}

      <Handle type="source" position={Position.Right} className="react-flow__handle" />
      {isUploading && <div className="absolute bottom-1 left-1 text-xs text-accent-cyan">Cargando...</div>}
    </div>
  );
};

export default memo(CompanyNode);

===== frontend/src/components/FileUploader.js =====
import React from 'react';

function FileUploader() {
  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    console.log(file);
  };

  return (
    <div>
      <input type="file" onChange={handleFileUpload} />
    </div>
  );
}

export default FileUploader;


===== frontend/src/components/GraphDisplay.js =====
import React from 'react';
import { Network } from 'vis-network';

function GraphDisplay() {
  React.useEffect(() => {
    const container = document.getElementById('graph');
    const data = {
      nodes: [
        { id: 1, label: 'Node 1' },
        { id: 2, label: 'Node 2' }
      ],
      edges: [
        { from: 1, to: 2 }
      ]
    };
    const options = {};
    new Network(container, data, options);
  }, []);

  return <div id="graph" style={{ height: '500px' }}></div>;
}

export default GraphDisplay;


===== frontend/src/components/AnimatedBackground.js =====
import React, { useEffect, useRef } from 'react';

const AnimatedBackground = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const can = canvasRef.current;
    if (!can) return;

    const ctx = can.getContext('2d');
    let animationFrameId;
    let pulseTimeoutId;

    // Get theme colors from CSS variables
    const computedStyle = getComputedStyle(document.documentElement);
    const bgColorPrimary = computedStyle.getPropertyValue('--body-color').trim() || '#05080D';
    const accentHue = parseInt(computedStyle.getPropertyValue('--hue').trim(), 10) || 200;

    // Convert bgColorPrimary to RGB
    let bgR = 5, bgG = 8, bgB = 13;
    if (bgColorPrimary.startsWith('#')) {
      const hex = bgColorPrimary.substring(1);
      if (hex.length === 3) {
        bgR = parseInt(hex[0] + hex[0], 16);
        bgG = parseInt(hex[1] + hex[1], 16);
        bgB = parseInt(hex[2] + hex[2], 16);
      } else if (hex.length === 6) {
        bgR = parseInt(hex.substring(0, 2), 16);
        bgG = parseInt(hex.substring(2, 4), 16);
        bgB = parseInt(hex.substring(4, 6), 16);
      }
    }
    const trailColor = `rgba(${bgR}, ${bgG}, ${bgB}, 0.15)`;
    const particleTrailColor = `rgba(${bgR}, ${bgG}, ${bgB}, 0.07)`;

    can.width = window.innerWidth;
    can.height = window.innerHeight;

    const particles = [];
    const maxParticles = 60;
    const connectionDistance = 150;
    const particleBaseRadius = 1.5;

    function drawBackgroundEffect() {
      ctx.fillStyle = trailColor;
      ctx.fillRect(0, 0, can.width, can.height);
      ctx.fillStyle = particleTrailColor;
      ctx.fillRect(0, 0, can.width, can.height);
    }

    function Particle(x, y, speed, color, radius) {
      this.x = x;
      this.y = y;
      this.vx = speed.x;
      this.vy = speed.y;
      this.color = color;
      this.radius = radius;
      this.initialLife = Math.random() * 150 + 150;
      this.life = this.initialLife;
      this.connections = 0;
      this.maxConnections = 3;

      this.draw = function () {
        const currentRadius = this.radius * (this.life / this.initialLife);
        if (currentRadius < 0.5) return;
        ctx.beginPath();
        ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2, false);
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
      };

      this.update = function () {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.5;
        // Soft bounce
        if (this.x + this.radius > can.width || this.x - this.radius < 0) {
          this.vx *= -0.7;
          this.x = Math.max(this.radius, Math.min(can.width - this.radius, this.x));
        }
        if (this.y + this.radius > can.height || this.y - this.radius < 0) {
          this.vy *= -0.7;
          this.y = Math.max(this.radius, Math.min(can.height - this.radius, this.y));
        }
        // Gentle random direction change
        if (Math.random() < 0.02) {
          const angleChange = (Math.random() - 0.5) * (Math.PI / 4);
          const currentAngle = Math.atan2(this.vy, this.vx);
          const magnitude = Math.sqrt(this.vx ** 2 + this.vy ** 2) * (0.8 + Math.random() * 0.4);
          this.vx = Math.cos(currentAngle + angleChange) * magnitude;
          this.vy = Math.sin(currentAngle + angleChange) * magnitude;
        }
        // Limit speed
        const maxSpeed = 1.5;
        const currentSpeed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
        if (currentSpeed > maxSpeed) {
          this.vx = (this.vx / currentSpeed) * maxSpeed;
          this.vy = (this.vy / currentSpeed) * maxSpeed;
        }
      };
    }

    function connectParticles() {
      particles.forEach(p => p.connections = 0);
      for (let i = 0; i < particles.length; i++) {
        if (particles[i].connections >= particles[i].maxConnections) continue;
        for (let j = i + 1; j < particles.length; j++) {
          if (particles[j].connections >= particles[j].maxConnections) continue;
          const dx = particles[i].x - particles[j].x;
          const dy = particles[i].y - particles[j].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < connectionDistance) {
            const opacity = Math.max(0, 1 - (distance / connectionDistance) * 0.8);
            ctx.beginPath();
            const connectionHue = accentHue;
            const connectionLightness = 60 + Math.random() * 10;
            ctx.strokeStyle = `hsla(${connectionHue}, 100%, ${connectionLightness}%, ${opacity * 0.4})`;
            ctx.lineWidth = 0.6;
            ctx.moveTo(particles[i].x, particles[i].y);
            ctx.lineTo(particles[j].x, particles[j].y);
            ctx.stroke();
            particles[i].connections++;
            particles[j].connections++;
            if (particles[i].connections >= particles[i].maxConnections) break;
          }
        }
      }
    }

    const particleBaseSpeed = 0.5;
    const pulsePeriod = 1200;
    const particlesPerPulse = 2;

    function pulse() {
      if (particles.length < maxParticles) {
        const numToSpawn = Math.min(particlesPerPulse, maxParticles - particles.length);
        for (let i = 0; i < numToSpawn; i++) {
          // Spawn from edges or random
          const edge = Math.floor(Math.random() * 4);
          let startX, startY;
          switch(edge) {
            case 0: // Top
              startX = Math.random() * can.width;
              startY = 0 - particleBaseRadius * 5;
              break;
            case 1: // Right
              startX = can.width + particleBaseRadius * 5;
              startY = Math.random() * can.height;
              break;
            case 2: // Bottom
              startX = Math.random() * can.width;
              startY = can.height + particleBaseRadius * 5;
              break;
            case 3: // Left
              startX = 0 - particleBaseRadius * 5;
              startY = Math.random() * can.height;
              break;
            default:
              startX = can.width / 2;
              startY = can.height / 2;
          }
          const angleToCenter = Math.atan2(can.height / 2 - startY, can.width / 2 - startX);
          const speedMagnitude = particleBaseSpeed * (0.7 + Math.random() * 0.6);
          const currentHue = accentHue + (Math.random() * 30 - 15);
          const color = `hsl(${currentHue}, 100%, 60%)`;
          particles.push(
            new Particle(
              startX,
              startY,
              {
                x: Math.cos(angleToCenter) * speedMagnitude + (Math.random() - 0.5) * 0.2,
                y: Math.sin(angleToCenter) * speedMagnitude + (Math.random() - 0.5) * 0.2,
              },
              color,
              particleBaseRadius + Math.random() * 2
            )
          );
        }
      }
      pulseTimeoutId = setTimeout(pulse, pulsePeriod + Math.random() * 800);
    }

    function gameMove() {
      drawBackgroundEffect();
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
      connectParticles();
      animationFrameId = requestAnimationFrame(gameMove);
    }

    const handleResize = () => {
      can.width = window.innerWidth;
      can.height = window.innerHeight;
    };

    window.addEventListener('resize', handleResize);

    // Inicializar con algunas partículas
    for(let k=0; k < Math.min(15, maxParticles); k++) {
      const angle = Math.random() * Math.PI * 2;
      const currentHue = accentHue + (Math.random() * 40 - 20);
      const color = `hsl(${currentHue}, 100%, 60%)`;
      particles.push(
        new Particle(
          can.width / 2 + (Math.random() - 0.5) * can.width * 0.5,
          can.height / 2 + (Math.random() - 0.5) * can.height * 0.5,
          {
            x: (Math.random() - 0.5) * particleBaseSpeed,
            y: (Math.random() - 0.5) * particleBaseSpeed,
          },
          color,
          particleBaseRadius + Math.random() * 1.5
        )
      );
    }

    pulse();
    gameMove();

    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationFrameId);
      clearTimeout(pulseTimeoutId);
      particles.length = 0;
    };
  }, []);

  return <canvas id="loginBackgroundCanvas" ref={canvasRef} />;
};

export default AnimatedBackground;


===== frontend/src/components/LoginForm.js =====
import React, { useState } from 'react';
import "../assets/css/styles.css";

function LoginForm() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log({ username, password });
  };

  return (
    <div className="login">
      <form className="login__form" onSubmit={handleSubmit}>
        <h1 className="login__title">Login</h1>
        <div className="login__content">
          <div className="login__box">
            <i className="login__icon ri-user-line"></i>
            <input
              type="text"
              className="login__input"
              placeholder=" "
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            <label className="login__label">Username</label>
          </div>
          <div className="login__box">
            <i className="login__icon ri-lock-line"></i>
            <input
              type="password"
              className="login__input"
              placeholder=" "
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            <label className="login__label">Password</label>
          </div>
        </div>
        <button type="submit" className="login__button">Login</button>
        <p className="login__register">
          Don't have an account? <a href="#">Register</a>
        </p>
      </form>
    </div>
  );
}

export default LoginForm;


===== frontend/src/components/NodeDetailPanel.js =====
import React from 'react';

function NodeDetailPanel() {
  return (
    <div>
      <h2>Node Details</h2>
      <p>Select a node to see details here.</p>
    </div>
  );
}

export default NodeDetailPanel;


===== frontend/public/index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>nodex</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>


===== frontend/Dockerfile =====
FROM node:18-alpine

WORKDIR /app

COPY package.json ./
COPY package-lock.json ./
COPY tsconfig.json ./
COPY eslint.config.mjs ./

RUN npm install --verbose

EXPOSE 3000

CMD ["npm", "start"]



===== backend/app/__init__.py =====


===== backend/app/models.py =====
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    disabled: Optional[bool] = None

class UserInDB(User):
    hashed_password: str

class Node(BaseModel):
    label: str
    properties: dict

# Puedes añadir más modelos para representar la estructura de tus nodos si es necesario
# class PersonNode(BaseModel):
#     curp: str
#     nombre_completo: str
#     # ... otros campos


===== backend/app/auth.py =====
import os
from datetime import datetime, timedelta
from typing import Optional, Dict
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from . import models

# Configuración (mejor en variables de entorno)
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "supersecretkey") # CAMBIA ESTO EN PRODUCCIÓN
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Base de datos de usuarios en memoria (SOLO PARA PoC)
fake_users_db: Dict[str, models.UserInDB] = {}

def init_fake_users_db():
    # Crear un usuario de ejemplo
    hashed_password = get_password_hash("testpassword")
    fake_users_db["testuser"] = models.UserInDB(
        username="testuser",
        email="testuser@example.com",
        full_name="Test User",
        hashed_password=hashed_password,
        disabled=False
    )

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def authenticate_user(db: dict, username: str, password: str) -> Optional[models.User]:
    user_in_db = db.get(username)
    if not user_in_db:
        return None
    if not verify_password(password, user_in_db.hashed_password):
        return None
    return models.User(**user_in_db.dict())

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = models.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user_dict = fake_users_db.get(token_data.username)
    if user_dict is None:
        raise credentials_exception
    user = models.User(**user_dict.dict()) # Convert UserInDB to User
    return user

async def get_current_active_user(current_user: models.User = Depends(get_current_user)):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


===== backend/app/crud.py =====
from neo4j import AsyncGraphDatabase
import os
from typing import Dict, Any, Tuple, List

NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD", "password")

driver = None

def init_db_connection():
    global driver
    driver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))

def close_db_connection():
    if driver:
        driver.close()

async def process_and_store_json(data: Dict[str, Any]):
    async with driver.session() as session:
        # Implementar lógica para procesar y almacenar datos JSON en Neo4j
        pass

async def get_all_graph_data() -> Tuple[List[Dict], List[Dict]]:
    async with driver.session() as session:
        result = await session.run("""
            MATCH (n)
            OPTIONAL MATCH (n)-[r]->(m)
            RETURN n, r, m
        """)
        
        nodes_dict = {}
        relationships_list = []

        async for record in result:
            node_n = record["n"]
            if node_n:
                node_id = node_n.element_id
                if node_id not in nodes_dict:
                    props = dict(node_n.items())
                    label = list(node_n.labels)[0] if node_n.labels else "Unknown"
                    nodes_dict[node_id] = {
                        "id": node_id,
                        "label": props.get("nombreCompleto", node_id),
                        "group": label,
                        "properties": props
                    }

            rel = record["r"]
            if rel:
                relationships_list.append({
                    "id": rel.element_id,
                    "from": rel.start_node.element_id,
                    "to": rel.end_node.element_id,
                    "label": rel.type,
                    "properties": dict(rel.items())
                })
        
        return list(nodes_dict.values()), relationships_list

async def get_node_properties(node_element_id: str) -> Dict:
    async with driver.session() as session:
        query = """
        MATCH (n) WHERE elementId(n) = $node_element_id
        RETURN properties(n) as props, labels(n) as labels
        """
        result = await session.run(query, node_element_id=node_element_id)
        record = await result.single()
        if record:
            return {"properties": record["props"], "labels": record["labels"]}
        return None


===== backend/app/main.py =====
import logging

# Silenciar el warning específico de passlib sobre la versión de bcrypt
logging.getLogger('passlib').setLevel(logging.ERROR)

from fastapi import FastAPI, File, UploadFile, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
import json
from typing import Any, Dict, List
from datetime import timedelta
from fastapi.responses import JSONResponse

from . import crud, models, auth

app = FastAPI(title="SIVG Backend")

# Configuración CORS (permitir peticiones desde el frontend)
origins = [
    "http://localhost:4545", # Puerto del frontend
    "http://localhost:3000", # Puerto de desarrollo de React
    "http://192.168.0.4:4545", # Nueva IP añadida
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    crud.init_db_connection()
    # Opcional: Crear constraints/indexes en Neo4j al inicio
    # await crud.create_constraints()

@app.on_event("shutdown")
async def shutdown_event():
    crud.close_db_connection()

@app.options("/token")
async def options_token():
    return JSONResponse(status_code=200, content={"message": "CORS preflight successful"})

@app.post("/token", response_model=models.Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    user = auth.authenticate_user(auth.fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=auth.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth.create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me/", response_model=models.User)
async def read_users_me(current_user: models.User = Depends(auth.get_current_active_user)):
    return current_user

@app.post("/upload-json/")
async def upload_json_file(
    file: UploadFile = File(...),
    current_user: models.User = Depends(auth.get_current_active_user) # Proteger endpoint
):
    try:
        contents = await file.read()
        data = json.loads(contents)
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON file")
    except Exception:
        raise HTTPException(status_code=500, detail="Error reading file")
    finally:
        await file.close()

    # Aquí llamas a la función que procesa el JSON y lo guarda en Neo4j
    try:
        await crud.process_and_store_json(data)
        return {"message": "JSON processed and data stored successfully."}
    except Exception as e:
        # Log the error e
        print(f"Error processing JSON: {e}")
        raise HTTPException(status_code=500, detail=f"Error processing JSON data: {str(e)}")

@app.get("/graph-data/")
async def get_graph_data(
    current_user: models.User = Depends(auth.get_current_active_user) # Proteger endpoint
):
    # Llama a una función en crud.py para obtener nodos y relaciones
    nodes, relationships = await crud.get_all_graph_data()
    return {"nodes": nodes, "edges": relationships}

@app.get("/node-details/{node_id}")
async def get_node_details(
    node_id: str, # O int, dependiendo de cómo identifiques tus nodos
    current_user: models.User = Depends(auth.get_current_active_user)
):
    details = await crud.get_node_properties(node_id)
    if not details:
        raise HTTPException(status_code=404, detail="Node not found")
    return details

# Inicializar la base de datos de usuarios falsos (para PoC)
auth.init_fake_users_db()


===== backend/sample_data.json =====
{
    "nodes": [
        {"label": "Person", "properties": {"name": "Alice", "age": 30}},
        {"label": "Person", "properties": {"name": "Bob", "age": 25}}
    ],
    "relationships": [
        {"start": "Alice", "end": "Bob", "type": "KNOWS"}
    ]
}


===== backend/requirements.txt =====
fastapi
uvicorn[standard]
neo4j
pydantic
python-jose[cryptography]
passlib[bcrypt]
python-multipart
bcrypt==4.0.1  # Fixed bcrypt version to avoid compatibility issues


===== backend/Dockerfile =====
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]


===== docker-compose.yml =====
version: '3.8'

services:
  neo4j:
    image: neo4j:4.4
    container_name: nodex_neo4j_v3  # Renamed container
    ports:
      - "7474:7474"
      - "7687:7687"
    volumes:
      - neo4j_data:/data
    environment:
      - NEO4J_AUTH=neo4j/yourStrongPassword
      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes

  backend:
    build: ./backend
    container_name: nodex_backend_v3  # Renamed container
    ports:
      - "0.0.0.0:8000:8000"
    volumes:
      - ./backend/app:/app/app
      - ./backend/sample_data.json:/app/sample_data.json
    depends_on:
      - neo4j
    environment:
      - NEO4J_URI=bolt://nodex_neo4j_v3:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=yourStrongPassword
      - JWT_SECRET_KEY=tu_super_secreto_jwt
      - ALGORITHM=HS256
      - ACCESS_TOKEN_EXPIRE_MINUTES=30

  frontend:
    build: ./frontend
    container_name: nodex_frontend_v3  # Renamed container
    ports:
      - "0.0.0.0:4545:3000"
    volumes:
      - ./frontend/src:/app/src
      - ./frontend/public:/app/public
    stdin_open: true
    tty: true
    depends_on:
      - backend
    environment:
      - WDS_SOCKET_HOST=0.0.0.0
      - WDS_SOCKET_PORT=4545
      - WDS_SOCKET_PATH=/ws

volumes:
  neo4j_data:


===== frontend/Dockerfile =====
FROM node:18-alpine

WORKDIR /app

COPY package.json ./
COPY package-lock.json ./
COPY tsconfig.json ./
COPY eslint.config.mjs ./

RUN npm install --verbose

EXPOSE 3000

CMD ["npm", "start"]



